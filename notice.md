# Общие замечания по поводу работы над проектом

## Code-style

### Авто-форматирование

Для форматирования кода следует использовать `astyle` со следущими параметрами командной строки:

`astyle --style=java --indent=tab=4 --attach-namespaces --attach-classes --attach-extern-c --indent-switches --indent-namespaces --indent-preproc-block --indent-preproc-cond --indent-preproc-define --pad-oper --pad-comma --pad-header --unpad-paren --fill-empty-lines --align-pointer=name --align-reference=name --add-brackets --remove-comment-prefix --lineend=linux <source code>`

Или проще:

`astyle --options=.astylerc <source code>`.

Файл опций `.astylerc` лежит в этом репозитории.

### Конструкторы

Оформление конструктора класса должно выглядеть следующим образом:

~~~~~
Constructor::Constructor(int a, int b)
	: m_a(a), m_b(b) {
	// operators
}
~~~~~

### Оператор switch

Оформление оператора `switch` должно выглядеть следующим образом:

~~~~~
switch (a) {
	case 1: {
		// operators
		break;
	}
	case 2: {
		// operators
		break;
	}
	...
	default: {
		// operators
	}
}
~~~~~

Наличие ветви `default` **обязательно**, ограждать случаи в `switch` фигурными скобками также **обязательно**.

### Именование переменных

Следует избегать коротких или однобуквенных названий переменных и функций, а так же названий, которые можно трактовать различными способами.

Примеры плохих названий переменных: `flag`, `x`, `cnt`, `num`, `ans`, `val`, `date`, `f`.

**Исключение:** допустимо (но не рекомендуется) использование переменной `i` в качестве локальной переменной-счётчика **простого** цикла `for`. Например, допустимо использование таких переменных для простого чтения или вывода массивов. В случае, если тело цикла содержит несколько команд или ветвление, использования однобуквенных переменных **следует избегать**.

Названия полей, методов класса и функций должны писаться в lowerCamelCase: `myLittleCamel`.

Названия классов, пространств имен и типов должны писаться в CamelCase: `MyBigCamel`.

Названия полей в `enum`, констант, а также макросов (которые  не рекомендуется использовать), нужно писать `БОЛЬШИМИ_БУКВАМИ`.

К названиям полей классов следует добавлять префикс `m_`: `m_начинатьСБуквыMЧтоЗначитMember`.

К названиям глобальных переменных стоит добавлять префикс `g_`: `g_начинатьСБуквыGЧтоЗначитGlobal`.

Названия переменных, содержащие цифры, лучше не использовать.

**Исключение**: в простейщих операторах (например, операторах сравнения), а также простейших функциях типа `min`, `max` допустимо использование переменных типа `item1`, `item2`.

## Возможности C++

Для целочисленных типов лучше использовать `int8_t`, `uint8_t`, `int16_t`, `uint16_t`, `int32_t`, `uint32_t`, `int64_t`, `uint64_t`, `intptr_t`, `uintptr_t` и `size_t`. Про `int`, `long long` и т. д. стоит забыть.

Директивы препроцессора `#define` и `#pragma` лучше избегать. `#define` хорошо использовать только для условной компиляции.

Писать `using namespace std;` не надо (особенно в заголовочных файлах).

Стоит избегать использования функций в стиле Си, вроде `scanf`, `printf`, `malloc`, `free`, `gets` и так далее.

Для прохода по контейнерам стоит использовать for each, например, так:

~~~~~
for (ItemType item: items) {
	// operators
}
~~~~~

Стоит активно использовать пространства имен, для разных частей системы&mdash; разные пространства имен.

На C++ можно писать код, полный трюков, однако так делать не стоит. Код должен быть максимально ясным и понятным. Не стоит делать несколько действий в одну строку. Например, вместо

~~~~~
while (a[i++] = --j);
~~~~~

стоит написать

~~~~~
while (j != 1) {
	--j;
	a[i] = j;
	++i;
}
~~~~~

Предпочитайте префиксный инкремент (`++i` вместо `i++`).

Заголовочные файлы должны иметь расширение `.hpp`, а исходники C++&mdash; расширение `.cpp`.

Для перечислений стоит использовать `enum class` вместо `enum`.

Не стоит использовать преобразования типов в стиле Си, используйте `static_cast<T>`.

Возможно, список будет пополняться.

## Работа с git

Для работы над проектом будет использоваться `git`. Каждый должен работать в своей ветке, которые потом будут сливаться вместе. Коммитить напрямую в ветку `master` можно только в особых случаях (например, исправление мелкого бага в уже существующем коде, которое можно сделать за один небольшой коммит). Перед тем, как коммитить в `master`, лучше согласовать это.

Сливать ветки в `master` может только главный по проекту. Для того, чтобы предложить слить свою ветку с `master`, лучше использовать механизм pull-request.

Коммиты должны быть логически законченными, содержать логически связанные изменения. Если коммитом затрагиваются слабо связанные между собой изменения, лучше разбить его на несколько.

Названия коммитов и pull-requestов должно быть осмысленное и отражать сделанные в них изменения.

## Спецификации

Следовать спецификациям в этом репозитории обязательно. Если вы считаете, что какую-то часть этих спецификаций стоит изменить, стоит сначала сделать pull-request в этот репозиторий.

Может получиться и так, что спецификации описывают не все. Если какая-то часть кода реализует незадокументированные в спецификациях возможности, стоит добавить информацию о них сюда.

Если часть спецификации сложна в реализации или оставлена на потом, стоит оставить TODO-комментарий в коде, чтобы эту часть спецификации можно было реализовать потом.
